s:set -c -x ;;
s:export wait-time = -wait=0.5 ;;
echo -D echo works ;;
echo -D ${wait-time} program args \a{*} ;;
echo -D ${wait-time} testing var-or (`\${fejwafjewafjewa||string}`) ${fejwafjewafjewa||string} ;;
s:export old-parser = $(options opts-parser >pipe> tail -count=1) ;;
s:option opts-parser with-negate ;;
echo -D ${wait-time} testing with-negate parser, and dofirst syntax\n$(opts -x -z=true +y) ;;
s:option opts-parser ${old-parser} ;;
echo -D ${wait-time} testing math syntax `\$[2+2]` = $[2+2] ;;
echo -D ${wait-time} testing syntax in math syntax `\$[Math.round(\$(rand))]` = $[ Math.round($(rand)) ] ;;
echo -D ${wait-time} testing pipes (`echo -D hi \>pipe> rev`) = $(echo -D hi >pipe> rev) ;;
for i 1..3 \{ 
    echo -D testing for loop, \${%:i}
} ;;
echo -D ${wait-time} testing long pipe (`echo -D \$(echo -D hello \>pipe> rev) \>pipe> echo -D {%} is neato`) = $(echo -D $(echo -D hello >pipe> rev) >pipe> echo -D {%} is neato) ;;
echo -D testing `argc hi\\sbye \\s{hi bye} \\y{$[3 + 3] is neat}` = $(argc hi\sbye \s{hi bye} \y{$[3+3] is neat})
